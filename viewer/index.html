<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shade MCP Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a1a; color: #fff; overflow: hidden; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
        #canvas { width: 100%; height: 100%; display: block; }
        #controls {
            position: fixed; top: 20px; right: 20px;
            background: rgba(0,0,0,0.85); border-radius: 8px; padding: 16px;
            min-width: 280px; max-width: 320px;
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); z-index: 100;
        }
        #controls h2 { font-size: 14px; font-weight: 600; margin-bottom: 16px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
        .param-group { margin-bottom: 12px; }
        .param-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .param-name { font-size: 12px; color: #ccc; }
        .param-value { font-size: 11px; color: #888; font-family: 'SF Mono', Monaco, monospace; }
        .param-slider { width: 100%; height: 6px; -webkit-appearance: none; appearance: none; background: #333; border-radius: 3px; outline: none; cursor: pointer; }
        .param-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: #fff; border-radius: 50%; cursor: pointer; }
        #effect-select { width: 100%; padding: 6px 8px; background: #333; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 12px; margin-bottom: 12px; }
        #backend-toggle { margin-bottom: 12px; }
        #backend-toggle label { font-size: 12px; color: #ccc; margin-right: 12px; cursor: pointer; }
        #status {
            position: fixed; bottom: 20px; left: 20px;
            background: rgba(0,0,0,0.85); border-radius: 8px; padding: 12px 16px;
            font-size: 12px; color: #888;
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); z-index: 100;
        }
        #status.error { color: #ff6b6b; border-color: rgba(255,107,107,0.3); }
        #status.success { color: #69db7c; }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div id="controls">
        <h2>Shade MCP</h2>
        <select id="effect-select"><option value="">Select effect...</option></select>
        <div id="backend-toggle">
            <span class="param-name" style="margin-bottom:6px;display:block;">Backend</span>
            <label><input type="radio" name="backend" value="glsl" checked> WebGL2</label>
            <label><input type="radio" name="backend" value="wgsl"> WebGPU</label>
        </div>
        <div id="params"></div>
    </div>

    <div id="status">Initializing...</div>

    <script type="module">
        import { CanvasRenderer, registerEffect as registerEffectGlobal, registerOp, registerStarterOps } from './vendor/noisemaker-shaders-core.esm.js';

        let renderer = null;
        let effectDef = null;
        let paramValues = {};
        let currentBackend = 'glsl';
        let canvas = document.getElementById('canvas');
        const statusEl = document.getElementById('status');
        const paramsEl = document.getElementById('params');
        const effectSelect = document.getElementById('effect-select');

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const w = window.innerWidth, h = window.innerHeight;
            canvas.width = w * dpr; canvas.height = h * dpr;
            canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
            if (renderer) renderer.resize(w, h);
        }

        function setStatus(message, type = '') {
            statusEl.textContent = message;
            statusEl.className = type;
        }

        function renderParamControls(def) {
            paramsEl.innerHTML = '';
            const globals = def.globals || {};
            for (const [name, spec] of Object.entries(globals)) {
                if (paramValues[name] === undefined) paramValues[name] = spec.default ?? 0;
                const group = document.createElement('div');
                group.className = 'param-group';
                const label = document.createElement('div');
                label.className = 'param-label';
                const nameSpan = document.createElement('span');
                nameSpan.className = 'param-name';
                nameSpan.textContent = name;
                const valueSpan = document.createElement('span');
                valueSpan.className = 'param-value';
                valueSpan.textContent = typeof paramValues[name] === 'number' ? paramValues[name].toFixed(2) : String(paramValues[name]);
                label.appendChild(nameSpan);
                label.appendChild(valueSpan);
                const slider = document.createElement('input');
                slider.type = 'range'; slider.className = 'param-slider';
                slider.min = spec.min ?? 0; slider.max = spec.max ?? 1;
                slider.step = spec.step ?? 0.01; slider.value = paramValues[name];
                slider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    paramValues[name] = val;
                    valueSpan.textContent = val.toFixed(2);
                    if (renderer) renderer.setUniform(name, val);
                });
                group.appendChild(label);
                group.appendChild(slider);
                paramsEl.appendChild(group);
            }
        }

        async function loadEffectDefinition(effectDir) {
            // Try definition.json first
            try {
                const resp = await fetch(`${effectDir}/definition.json`, { cache: 'no-store' });
                if (resp.ok) {
                    const def = await resp.json();
                    def.shaders = def.shaders || {};
                    for (const p of (def.passes || [])) {
                        def.shaders[p.program] = def.shaders[p.program] || {};
                        try {
                            const g = await fetch(`${effectDir}/glsl/${p.program}.glsl`, { cache: 'no-store' });
                            if (g.ok) def.shaders[p.program].glsl = await g.text();
                        } catch {}
                        try {
                            const w = await fetch(`${effectDir}/wgsl/${p.program}.wgsl`, { cache: 'no-store' });
                            if (w.ok) def.shaders[p.program].wgsl = await w.text();
                        } catch {}
                    }
                    def._effectDir = effectDir;
                    return def;
                }
            } catch {}
            throw new Error(`Failed to load effect from ${effectDir}`);
        }

        async function compileAndRun(def) {
            try {
                effectDef = def;
                const ns = def.namespace || 'unknown';
                const name = def.func;
                const opName = `${ns}.${name}`;

                const globals = def.globals || {};
                const args = Object.entries(globals).map(([n, s]) => ({
                    name: n, type: s.type === 'vec4' ? 'color' : (s.type || 'float'),
                    default: s.default ?? 0, min: s.min, max: s.max, uniform: s.uniform || n
                }));

                registerOp(opName, { name, args });
                registerStarterOps([opName]);
                const instance = {
                    name: def.name, namespace: ns, func: name, description: def.description,
                    tags: def.tags || [], globals, passes: def.passes || [],
                    shaders: def.shaders || {}, starter: def.starter || false
                };
                registerEffectGlobal(opName, instance);
                registerEffectGlobal(`${ns}/${name}`, instance);

                renderParamControls(def);
                paramValues = {};

                const dsl = `search ${ns}\n${name}().write(o0)\nrender(o0)`;
                await renderer.compile(dsl);

                for (const [n, v] of Object.entries(paramValues)) {
                    renderer.setUniform(n, v);
                }

                setStatus(`Loaded: ${opName} (${currentBackend === 'wgsl' ? 'WebGPU' : 'WebGL2'})`, 'success');
            } catch (err) {
                const msg = err?.diagnostics?.map(d => d.message).join('; ') || err?.message || String(err);
                setStatus(msg, 'error');
                console.error('Effect load error:', msg);
            }
        }

        async function initRenderer() {
            if (renderer) renderer.stop();
            const old = canvas;
            const nc = document.createElement('canvas');
            nc.id = 'canvas'; nc.style.width = old.style.width; nc.style.height = old.style.height;
            nc.width = old.width; nc.height = old.height;
            old.parentNode.replaceChild(nc, old);
            canvas = nc;
            renderer = new CanvasRenderer({
                canvas, basePath: '/shaders',
                preferWebGPU: currentBackend === 'wgsl', useBundles: false
            });
            await renderer.loadManifest();
        }

        async function init() {
            try {
                setStatus('Initializing renderer...');
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                await initRenderer();

                // Populate effect select from manifest
                try {
                    const resp = await fetch('/effects/manifest.json', { cache: 'no-store' });
                    if (resp.ok) {
                        const manifest = await resp.json();
                        const effects = manifest.effects || Object.keys(manifest);
                        for (const id of effects) {
                            const opt = document.createElement('option');
                            opt.value = id; opt.textContent = id;
                            effectSelect.appendChild(opt);
                        }
                    }
                } catch {}

                // Expose globals for MCP browser harness
                Object.defineProperty(window, '__shadeCanvasRenderer', { get: () => renderer, configurable: true });
                Object.defineProperty(window, '__shadeRenderingPipeline', { get: () => renderer?.pipeline, configurable: true });
                window.__shadeCurrentBackend = () => {
                    const name = renderer?.pipeline?.backend?.getName?.() || '';
                    return name.toLowerCase().includes('webgpu') ? 'wgsl' : 'glsl';
                };
                window.__shadeSetPaused = (paused) => { if (paused) renderer?.stop(); else renderer?.start(); };
                window.__shadeSetPausedTime = (time) => { renderer?.render(time); };
                Object.defineProperty(window, '__shadeFrameCount', { get: () => renderer?.pipeline?.frameIndex ?? 0, configurable: true });
                window.__shadeCurrentEffect = null;

                effectSelect.addEventListener('change', async (e) => {
                    const id = e.target.value;
                    if (!id) return;
                    setStatus('Loading effect...');
                    const parts = id.split('/');
                    const effectDir = `/effects/${parts.join('/')}`;
                    const def = await loadEffectDefinition(effectDir);
                    window.__shadeCurrentEffect = { id, instance: def };
                    await compileAndRun(def);
                    renderer.start();
                });

                document.querySelectorAll('input[name="backend"]').forEach(radio => {
                    radio.addEventListener('change', async (e) => {
                        currentBackend = e.target.value;
                        await initRenderer();
                        if (effectDef) {
                            await compileAndRun(effectDef);
                            renderer.start();
                        }
                    });
                });

                renderer.start();
                setStatus('Ready', 'success');
            } catch (err) {
                setStatus(`Init failed: ${err.message}`, 'error');
                console.error(err);
            }
        }

        init();
    </script>
</body>
</html>
